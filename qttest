#Problems to fix
# Make image load to center of screen, and scaled so that it fits inside
# Fix image movement and scaling when resizing app
# maintain image position/[relative scale] when fullscreening app (f11)
#fix image scrolling? Might not be necesarry

import os, sys
from PyQt6.QtWidgets import *#QApplication, QMainWindow, QWidget, QGraphicsView, QGraphicsScene
from PyQt6.QtGui import QPixmap, QColor, QPen, QBrush
from PyQt6.QtCore import Qt, QRectF, QPointF, QSizeF

zoom_step = 1.2 # Amount by which image will zoom on scrolling
zoom_scale = 1 #  Scale of image to display on screen
zoom_level = 0 #  How zoomed in/out the image is
image_index = 0

app = QApplication(sys.argv)
window = QMainWindow()
centralwidget = QWidget(window)
layout = QVBoxLayout(centralwidget)
view = QGraphicsView()
scene = QGraphicsScene()
# pixmap = QPixmap('images/pixel.png')
pixmap = QPixmap('images/largeimage.jpg')
# pixmap = QPixmap('images/transparent.png')

window.setWindowTitle("Window Title")
window.setGeometry(800, 50, 1000, 500) #app init x, y, w, h
window.setCentralWidget(centralwidget)

layout.setContentsMargins(5,5,5,5)
layout.addWidget(view)

view.setStyleSheet("background-color: green")
view.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
view.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
view.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
#view.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter) ?does anything
view.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
view.setScene(scene)

image = scene.addPixmap(pixmap)
image_ratio = pixmap.width()/pixmap.height()

def mousePressEvent(event):
    print(event.pos().x(), event.pos().y())

def keyPressEvent(event):
    global image_index
    print(event.key())
    if   event.key() == Qt.Key.Key_Escape: app.quit()
    elif event.key() == Qt.Key.Key_F11: 
        view.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorViewCenter)
        window.showNormal() if window.isFullScreen() else window.showFullScreen()
        view.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
    elif event.key() == Qt.Key.Key_Right :
        image_index = (image_index + 1) % len(os.listdir('images'))
        updateImage(image_index)
    elif event.key() == Qt.Key.Key_Left : 
        image_index = (image_index - 1) % len(os.listdir('images'))
        updateImage(image_index)        
    elif event.key() == Qt.Key.Key_Space : updateSceneRect()
    event.accept()

def wheelEvent(event):
    global zoom_scale, zoom_level, pixmap
    if event.angleDelta().x() + event.angleDelta().y() > 0:
        view.scale(zoom_step, zoom_step)
        # zoom_scale *= zoom_step
        zoom_level += 1 #if (pixmap.height()*zoom_scale) > view.height() or (pixmap.width() *zoom_scale)> view.width() else zoom_level + 1
    elif zoom_level > -99:
        view.scale(1/zoom_step, 1/zoom_step)
        # zoom_scale /= zoom_step
        zoom_level -= 1
    updateSceneRect()
    print(round(zoom_scale, 3), zoom_level)
    event.accept()

def resizeEvent(event = None):
    ## FIX ERROR CROPS SMALL PIECE
    global image_ratio, zoom_scale, zoom_level, scene

    view_ratio = view.width()/view.height()
    widthratio = view.width()/(pixmap.width()*zoom_scale)
    heightratio = view.height()/(pixmap.height()*zoom_scale)
    if view_ratio < image_ratio:
        zoom_scale*= widthratio
        view.scale(widthratio, widthratio)
    else:
        zoom_scale*= heightratio
        view.scale(heightratio, heightratio)
    updateSceneRect()

    #elif zoom_level < 0: 
    #    if heightratio < 1 or widthratio < 1: zoom_level = 0
    #else:
    #    pass#print(widthratio, heightratio)

def updateSceneRect():
    global scene, image

    viewport_rect = view.mapToScene(view.viewport().geometry()).boundingRect()

    top_distance = -1 * viewport_rect.top()
    left_distance = -1 * viewport_rect.left()
    bottom_distance = viewport_rect.bottom()-pixmap.height()
    right_distance = viewport_rect.right()-pixmap.width()
        
    # Create a new QRectF with the desired coordinates
    
    #Method 1
    rect = scene.sceneRect()
    rect.moveCenter(scene.sceneRect().center())
    rect.setTop(viewport_rect.top()-pixmap.height()-bottom_distance)
    rect.setLeft(viewport_rect.left()-pixmap.width()-right_distance)
    rect.setBottom(viewport_rect.bottom()+pixmap.height()+top_distance)
    rect.setRight(viewport_rect.right()+pixmap.width()+left_distance)
    
    #Method 2
    #rect = QRectF(
    #        QPointF(
    #            viewport_rect.right()+pixmap.width()+left_distance,
    #            viewport_rect.bottom()+pixmap.height()+top_distance),
    #        QPointF(
    #            viewport_rect.left()-pixmap.width()-right_distance,
    #            viewport_rect.top()-pixmap.height()-bottom_distance))
    
    scene.setSceneRect(rect)
    print("Image pos", image.pos().x(), image.pos().y())

def updateImage( image_index : int):
    global image, pixmap
    pixmap = QPixmap(os.listdir('Images')[image_index])
    scene.removeItem(image)
    image = scene.addPixmap(pixmap)
    resizeEvent()

view.wheelEvent = wheelEvent
view.keyPressEvent = keyPressEvent
window.resizeEvent = resizeEvent
#view.mousePressEvent = mousePressEvent

window.showNormal()
window.resizeEvent()

sys.exit(app.exec())


#Switch Image
#pixmap = QPixmap('newimage')
#scene.removeItem(image)
#image = scene.addPixmap(pixmap)
#resizeEvent()